const ft=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function yt(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function sn(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function k(t,...e){if(!yt(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function ue(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function cn(t,e){k(t);const n=e.outputLen;if(t.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}function Xt(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}function Lt(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}const Ie=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",fn=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function Tt(t){if(k(t),Ie)return t.toHex();let e="";for(let n=0;n<t.length;n++)e+=fn[t[n]];return e}const P={_0:48,_9:57,A:65,F:70,a:97,f:102};function le(t){if(t>=P._0&&t<=P._9)return t-P._0;if(t>=P.A&&t<=P.F)return t-(P.A-10);if(t>=P.a&&t<=P.f)return t-(P.a-10)}function qe(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(Ie)return Uint8Array.fromHex(t);const e=t.length,n=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let s=0,o=0;s<n;s++,o+=2){const i=le(t.charCodeAt(o)),f=le(t.charCodeAt(o+1));if(i===void 0||f===void 0){const c=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+o)}r[s]=i*16+f}return r}function dt(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}function Ne(t){return typeof t=="string"&&(t=dt(t)),k(t),t}function F(...t){let e=0;for(let r=0;r<t.length;r++){const s=t[r];k(s),e+=s.length}const n=new Uint8Array(e);for(let r=0,s=0;r<t.length;r++){const o=t[r];n.set(o,s),s+=o.length}return n}class an{}function un(t){const e=r=>t().update(Ne(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function Te(t=32){if(ft&&typeof ft.getRandomValues=="function")return ft.getRandomValues(new Uint8Array(t));if(ft&&typeof ft.randomBytes=="function")return Uint8Array.from(ft.randomBytes(t));throw new Error("crypto.getRandomValues must be defined")}function ln(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const s=BigInt(32),o=BigInt(4294967295),i=Number(n>>s&o),f=Number(n&o),c=r?4:0,u=r?0:4;t.setUint32(e+c,i,r),t.setUint32(e+u,f,r)}class dn extends an{constructor(e,n,r,s){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=s,this.buffer=new Uint8Array(e),this.view=Lt(this.buffer)}update(e){ue(this),e=Ne(e),k(e);const{view:n,buffer:r,blockLen:s}=this,o=e.length;for(let i=0;i<o;){const f=Math.min(s-this.pos,o-i);if(f===s){const c=Lt(e);for(;s<=o-i;i+=s)this.process(c,i);continue}r.set(e.subarray(i,i+f),this.pos),this.pos+=f,i+=f,this.pos===s&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){ue(this),cn(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:s,isLE:o}=this;let{pos:i}=this;n[i++]=128,Xt(this.buffer.subarray(i)),this.padOffset>s-i&&(this.process(r,0),i=0);for(let g=i;g<s;g++)n[g]=0;ln(r,s-8,BigInt(this.length*8),o),this.process(r,0);const f=Lt(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const u=c/4,l=this.get();if(u>l.length)throw new Error("_sha2: outputLen bigger than state");for(let g=0;g<u;g++)f.setUint32(4*g,l[g],o)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:s,finished:o,destroyed:i,pos:f}=this;return e.destroyed=i,e.finished=o,e.length=s,e.pos=f,s%n&&e.buffer.set(r),e}clone(){return this._cloneInto()}}const D=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),Bt=BigInt(2**32-1),de=BigInt(32);function hn(t,e=!1){return e?{h:Number(t&Bt),l:Number(t>>de&Bt)}:{h:Number(t>>de&Bt)|0,l:Number(t&Bt)|0}}function gn(t,e=!1){const n=t.length;let r=new Uint32Array(n),s=new Uint32Array(n);for(let o=0;o<n;o++){const{h:i,l:f}=hn(t[o],e);[r[o],s[o]]=[i,f]}return[r,s]}const he=(t,e,n)=>t>>>n,ge=(t,e,n)=>t<<32-n|e>>>n,at=(t,e,n)=>t>>>n|e<<32-n,ut=(t,e,n)=>t<<32-n|e>>>n,Et=(t,e,n)=>t<<64-n|e>>>n-32,_t=(t,e,n)=>t>>>n-32|e<<64-n;function Q(t,e,n,r){const s=(e>>>0)+(r>>>0);return{h:t+n+(s/2**32|0)|0,l:s|0}}const wn=(t,e,n)=>(t>>>0)+(e>>>0)+(n>>>0),bn=(t,e,n,r)=>e+n+r+(t/2**32|0)|0,mn=(t,e,n,r)=>(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0),yn=(t,e,n,r,s)=>e+n+r+s+(t/2**32|0)|0,xn=(t,e,n,r,s)=>(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0)+(s>>>0),pn=(t,e,n,r,s,o)=>e+n+r+s+o+(t/2**32|0)|0,Oe=gn(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(t=>BigInt(t))),Bn=Oe[0],En=Oe[1],tt=new Uint32Array(80),et=new Uint32Array(80);class _n extends dn{constructor(e=64){super(128,e,16,!1),this.Ah=D[0]|0,this.Al=D[1]|0,this.Bh=D[2]|0,this.Bl=D[3]|0,this.Ch=D[4]|0,this.Cl=D[5]|0,this.Dh=D[6]|0,this.Dl=D[7]|0,this.Eh=D[8]|0,this.El=D[9]|0,this.Fh=D[10]|0,this.Fl=D[11]|0,this.Gh=D[12]|0,this.Gl=D[13]|0,this.Hh=D[14]|0,this.Hl=D[15]|0}get(){const{Ah:e,Al:n,Bh:r,Bl:s,Ch:o,Cl:i,Dh:f,Dl:c,Eh:u,El:l,Fh:g,Fl:a,Gh:w,Gl:h,Hh:p,Hl:y}=this;return[e,n,r,s,o,i,f,c,u,l,g,a,w,h,p,y]}set(e,n,r,s,o,i,f,c,u,l,g,a,w,h,p,y){this.Ah=e|0,this.Al=n|0,this.Bh=r|0,this.Bl=s|0,this.Ch=o|0,this.Cl=i|0,this.Dh=f|0,this.Dl=c|0,this.Eh=u|0,this.El=l|0,this.Fh=g|0,this.Fl=a|0,this.Gh=w|0,this.Gl=h|0,this.Hh=p|0,this.Hl=y|0}process(e,n){for(let b=0;b<16;b++,n+=4)tt[b]=e.getUint32(n),et[b]=e.getUint32(n+=4);for(let b=16;b<80;b++){const A=tt[b-15]|0,I=et[b-15]|0,N=at(A,I,1)^at(A,I,8)^he(A,I,7),U=ut(A,I,1)^ut(A,I,8)^ge(A,I,7),q=tt[b-2]|0,x=et[b-2]|0,E=at(q,x,19)^Et(q,x,61)^he(q,x,6),S=ut(q,x,19)^_t(q,x,61)^ge(q,x,6),T=mn(U,S,et[b-7],et[b-16]),_=yn(T,N,E,tt[b-7],tt[b-16]);tt[b]=_|0,et[b]=T|0}let{Ah:r,Al:s,Bh:o,Bl:i,Ch:f,Cl:c,Dh:u,Dl:l,Eh:g,El:a,Fh:w,Fl:h,Gh:p,Gl:y,Hh:d,Hl:B}=this;for(let b=0;b<80;b++){const A=at(g,a,14)^at(g,a,18)^Et(g,a,41),I=ut(g,a,14)^ut(g,a,18)^_t(g,a,41),N=g&w^~g&p,U=a&h^~a&y,q=xn(B,I,U,En[b],et[b]),x=pn(q,d,A,N,Bn[b],tt[b]),E=q|0,S=at(r,s,28)^Et(r,s,34)^Et(r,s,39),T=ut(r,s,28)^_t(r,s,34)^_t(r,s,39),_=r&o^r&f^o&f,v=s&i^s&c^i&c;d=p|0,B=y|0,p=w|0,y=h|0,w=g|0,h=a|0,{h:g,l:a}=Q(u|0,l|0,x|0,E|0),u=f|0,l=c|0,f=o|0,c=i|0,o=r|0,i=s|0;const O=wn(E,T,v);r=bn(O,x,S,_),s=O|0}({h:r,l:s}=Q(this.Ah|0,this.Al|0,r|0,s|0)),{h:o,l:i}=Q(this.Bh|0,this.Bl|0,o|0,i|0),{h:f,l:c}=Q(this.Ch|0,this.Cl|0,f|0,c|0),{h:u,l}=Q(this.Dh|0,this.Dl|0,u|0,l|0),{h:g,l:a}=Q(this.Eh|0,this.El|0,g|0,a|0),{h:w,l:h}=Q(this.Fh|0,this.Fl|0,w|0,h|0),{h:p,l:y}=Q(this.Gh|0,this.Gl|0,p|0,y|0),{h:d,l:B}=Q(this.Hh|0,this.Hl|0,d|0,B|0),this.set(r,s,o,i,f,c,u,l,g,a,w,h,p,y,d,B)}roundClean(){Xt(tt,et)}destroy(){Xt(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const bt=un(()=>new _n);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Pt=BigInt(0),jt=BigInt(1);function $t(t,e=""){if(typeof t!="boolean"){const n=e&&`"${e}"`;throw new Error(n+"expected boolean, got type="+typeof t)}return t}function St(t,e,n=""){const r=yt(t),s=t==null?void 0:t.length,o=e!==void 0;if(!r||o&&s!==e){const i=n&&`"${n}" `,f=o?` of length ${e}`:"",c=r?`length=${s}`:`type=${typeof t}`;throw new Error(i+"expected Uint8Array"+f+", got "+c)}return t}function Ue(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?Pt:BigInt("0x"+t)}function Ze(t){return Ue(Tt(t))}function st(t){return k(t),Ue(Tt(Uint8Array.from(t).reverse()))}function Ce(t,e){return qe(t.toString(16).padStart(e*2,"0"))}function Le(t,e){return Ce(t,e).reverse()}function X(t,e,n){let r;if(typeof e=="string")try{r=qe(e)}catch(o){throw new Error(t+" must be hex string or Uint8Array, cause: "+o)}else if(yt(e))r=Uint8Array.from(e);else throw new Error(t+" must be hex string or Uint8Array");const s=r.length;if(typeof n=="number"&&s!==n)throw new Error(t+" of length "+n+" expected, got "+s);return r}function vn(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return n===0}function we(t){return Uint8Array.from(t)}const Mt=t=>typeof t=="bigint"&&Pt<=t;function An(t,e,n){return Mt(t)&&Mt(e)&&Mt(n)&&e<=t&&t<n}function It(t,e,n,r){if(!An(e,n,r))throw new Error("expected valid "+t+": "+n+" <= n < "+r+", got "+e)}function Sn(t){let e;for(e=0;t>Pt;t>>=jt,e+=1);return e}const Qt=t=>(jt<<BigInt(t))-jt;function In(t){return typeof t=="function"&&Number.isSafeInteger(t.outputLen)}function xt(t,e,n={}){if(!t||typeof t!="object")throw new Error("expected valid options object");function r(s,o,i){const f=t[s];if(i&&f===void 0)return;const c=typeof f;if(c!==o||f===null)throw new Error(`param "${s}" is invalid: expected ${o}, got ${c}`)}Object.entries(e).forEach(([s,o])=>r(s,o,!1)),Object.entries(n).forEach(([s,o])=>r(s,o,!0))}const be=()=>{throw new Error("not implemented")};function me(t){const e=new WeakMap;return(n,...r)=>{const s=e.get(n);if(s!==void 0)return s;const o=t(n,...r);return e.set(n,o),o}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const j=BigInt(0),Y=BigInt(1),it=BigInt(2),Me=BigInt(3),Re=BigInt(4),He=BigInt(5),qn=BigInt(7),Ve=BigInt(8),Nn=BigInt(9),De=BigInt(16);function Z(t,e){const n=t%e;return n>=j?n:e+n}function z(t,e,n){let r=t;for(;e-- >j;)r*=r,r%=n;return r}function ye(t,e){if(t===j)throw new Error("invert: expected non-zero number");if(e<=j)throw new Error("invert: expected positive modulus, got "+e);let n=Z(t,e),r=e,s=j,o=Y;for(;n!==j;){const f=r/n,c=r%n,u=s-o*f;r=n,n=c,s=o,o=u}if(r!==Y)throw new Error("invert: does not exist");return Z(s,e)}function Ft(t,e,n){if(!t.eql(t.sqr(e),n))throw new Error("Cannot find square root")}function Ye(t,e){const n=(t.ORDER+Y)/Re,r=t.pow(e,n);return Ft(t,r,e),r}function Tn(t,e){const n=(t.ORDER-He)/Ve,r=t.mul(e,it),s=t.pow(r,n),o=t.mul(e,s),i=t.mul(t.mul(o,it),s),f=t.mul(o,t.sub(i,t.ONE));return Ft(t,f,e),f}function On(t){const e=ht(t),n=Xe(t),r=n(e,e.neg(e.ONE)),s=n(e,r),o=n(e,e.neg(r)),i=(t+qn)/De;return(f,c)=>{let u=f.pow(c,i),l=f.mul(u,r);const g=f.mul(u,s),a=f.mul(u,o),w=f.eql(f.sqr(l),c),h=f.eql(f.sqr(g),c);u=f.cmov(u,l,w),l=f.cmov(a,g,h);const p=f.eql(f.sqr(l),c),y=f.cmov(u,l,p);return Ft(f,y,c),y}}function Xe(t){if(t<Me)throw new Error("sqrt is not defined for small field");let e=t-Y,n=0;for(;e%it===j;)e/=it,n++;let r=it;const s=ht(t);for(;xe(s,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(n===1)return Ye;let o=s.pow(r,e);const i=(e+Y)/it;return function(c,u){if(c.is0(u))return u;if(xe(c,u)!==1)throw new Error("Cannot find square root");let l=n,g=c.mul(c.ONE,o),a=c.pow(u,e),w=c.pow(u,i);for(;!c.eql(a,c.ONE);){if(c.is0(a))return c.ZERO;let h=1,p=c.sqr(a);for(;!c.eql(p,c.ONE);)if(h++,p=c.sqr(p),h===l)throw new Error("Cannot find square root");const y=Y<<BigInt(l-h-1),d=c.pow(g,y);l=h,g=c.sqr(d),a=c.mul(a,g),w=c.mul(w,d)}return w}}function Un(t){return t%Re===Me?Ye:t%Ve===He?Tn:t%De===Nn?On(t):Xe(t)}const rt=(t,e)=>(Z(t,e)&Y)===Y,Zn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Cn(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},n=Zn.reduce((r,s)=>(r[s]="function",r),e);return xt(t,n),t}function Ln(t,e,n){if(n<j)throw new Error("invalid exponent, negatives unsupported");if(n===j)return t.ONE;if(n===Y)return e;let r=t.ONE,s=e;for(;n>j;)n&Y&&(r=t.mul(r,s)),s=t.sqr(s),n>>=Y;return r}function Jt(t,e,n=!1){const r=new Array(e.length).fill(n?t.ZERO:void 0),s=e.reduce((i,f,c)=>t.is0(f)?i:(r[c]=i,t.mul(i,f)),t.ONE),o=t.inv(s);return e.reduceRight((i,f,c)=>t.is0(f)?i:(r[c]=t.mul(i,r[c]),t.mul(i,f)),o),r}function xe(t,e){const n=(t.ORDER-Y)/it,r=t.pow(e,n),s=t.eql(r,t.ONE),o=t.eql(r,t.ZERO),i=t.eql(r,t.neg(t.ONE));if(!s&&!o&&!i)throw new Error("invalid Legendre symbol result");return s?1:o?0:-1}function Mn(t,e){e!==void 0&&sn(e);const n=e!==void 0?e:t.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function ht(t,e,n=!1,r={}){if(t<=j)throw new Error("invalid field: expected ORDER > 0, got "+t);let s,o,i=!1,f;if(typeof e=="object"&&e!=null){if(r.sqrt||n)throw new Error("cannot specify opts in two arguments");const a=e;a.BITS&&(s=a.BITS),a.sqrt&&(o=a.sqrt),typeof a.isLE=="boolean"&&(n=a.isLE),typeof a.modFromBytes=="boolean"&&(i=a.modFromBytes),f=a.allowedLengths}else typeof e=="number"&&(s=e),r.sqrt&&(o=r.sqrt);const{nBitLength:c,nByteLength:u}=Mn(t,s);if(u>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let l;const g=Object.freeze({ORDER:t,isLE:n,BITS:c,BYTES:u,MASK:Qt(c),ZERO:j,ONE:Y,allowedLengths:f,create:a=>Z(a,t),isValid:a=>{if(typeof a!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof a);return j<=a&&a<t},is0:a=>a===j,isValidNot0:a=>!g.is0(a)&&g.isValid(a),isOdd:a=>(a&Y)===Y,neg:a=>Z(-a,t),eql:(a,w)=>a===w,sqr:a=>Z(a*a,t),add:(a,w)=>Z(a+w,t),sub:(a,w)=>Z(a-w,t),mul:(a,w)=>Z(a*w,t),pow:(a,w)=>Ln(g,a,w),div:(a,w)=>Z(a*ye(w,t),t),sqrN:a=>a*a,addN:(a,w)=>a+w,subN:(a,w)=>a-w,mulN:(a,w)=>a*w,inv:a=>ye(a,t),sqrt:o||(a=>(l||(l=Un(t)),l(g,a))),toBytes:a=>n?Le(a,u):Ce(a,u),fromBytes:(a,w=!0)=>{if(f){if(!f.includes(a.length)||a.length>u)throw new Error("Field.fromBytes: expected "+f+" bytes, got "+a.length);const p=new Uint8Array(u);p.set(a,n?0:p.length-a.length),a=p}if(a.length!==u)throw new Error("Field.fromBytes: expected "+u+" bytes, got "+a.length);let h=n?st(a):Ze(a);if(i&&(h=Z(h,t)),!w&&!g.isValid(h))throw new Error("invalid field element: outside of range 0..ORDER");return h},invertBatch:a=>Jt(g,a),cmov:(a,w,h)=>h?w:a});return Object.freeze(g)}function Rn(t,e){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const n=t.sqrt(e);return t.isOdd(n)?t.neg(n):n}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const qt=BigInt(0),kt=BigInt(1);function pe(t,e){const n=e.negate();return t?n:e}function vt(t,e){const n=Jt(t.Fp,e.map(r=>r.Z));return e.map((r,s)=>t.fromAffine(r.toAffine(n[s])))}function je(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function Rt(t,e){je(t,e);const n=Math.ceil(e/t)+1,r=2**(t-1),s=2**t,o=Qt(t),i=BigInt(t);return{windows:n,windowSize:r,mask:o,maxNumber:s,shiftBy:i}}function Be(t,e,n){const{windowSize:r,mask:s,maxNumber:o,shiftBy:i}=n;let f=Number(t&s),c=t>>i;f>r&&(f-=o,c+=kt);const u=e*r,l=u+Math.abs(f)-1,g=f===0,a=f<0,w=e%2!==0;return{nextN:c,offset:l,isZero:g,isNeg:a,isNegF:w,offsetF:u}}function Hn(t,e){if(!Array.isArray(t))throw new Error("array expected");t.forEach((n,r)=>{if(!(n instanceof e))throw new Error("invalid point at index "+r)})}function Vn(t,e){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((n,r)=>{if(!e.isValid(n))throw new Error("invalid scalar at index "+r)})}const Ht=new WeakMap,$e=new WeakMap;function Vt(t){return $e.get(t)||1}function Ee(t){if(t!==qt)throw new Error("invalid wNAF")}class Dn{constructor(e,n){this.BASE=e.BASE,this.ZERO=e.ZERO,this.Fn=e.Fn,this.bits=n}_unsafeLadder(e,n,r=this.ZERO){let s=e;for(;n>qt;)n&kt&&(r=r.add(s)),s=s.double(),n>>=kt;return r}precomputeWindow(e,n){const{windows:r,windowSize:s}=Rt(n,this.bits),o=[];let i=e,f=i;for(let c=0;c<r;c++){f=i,o.push(f);for(let u=1;u<s;u++)f=f.add(i),o.push(f);i=f.double()}return o}wNAF(e,n,r){if(!this.Fn.isValid(r))throw new Error("invalid scalar");let s=this.ZERO,o=this.BASE;const i=Rt(e,this.bits);for(let f=0;f<i.windows;f++){const{nextN:c,offset:u,isZero:l,isNeg:g,isNegF:a,offsetF:w}=Be(r,f,i);r=c,l?o=o.add(pe(a,n[w])):s=s.add(pe(g,n[u]))}return Ee(r),{p:s,f:o}}wNAFUnsafe(e,n,r,s=this.ZERO){const o=Rt(e,this.bits);for(let i=0;i<o.windows&&r!==qt;i++){const{nextN:f,offset:c,isZero:u,isNeg:l}=Be(r,i,o);if(r=f,!u){const g=n[c];s=s.add(l?g.negate():g)}}return Ee(r),s}getPrecomputes(e,n,r){let s=Ht.get(n);return s||(s=this.precomputeWindow(n,e),e!==1&&(typeof r=="function"&&(s=r(s)),Ht.set(n,s))),s}cached(e,n,r){const s=Vt(e);return this.wNAF(s,this.getPrecomputes(s,e,r),n)}unsafe(e,n,r,s){const o=Vt(e);return o===1?this._unsafeLadder(e,n,s):this.wNAFUnsafe(o,this.getPrecomputes(o,e,r),n,s)}createCache(e,n){je(n,this.bits),$e.set(e,n),Ht.delete(e)}hasCache(e){return Vt(e)!==1}}function ke(t,e,n,r){Hn(n,t),Vn(r,e);const s=n.length,o=r.length;if(s!==o)throw new Error("arrays of points and scalars must have equal length");const i=t.ZERO,f=Sn(BigInt(s));let c=1;f>12?c=f-3:f>4?c=f-2:f>0&&(c=2);const u=Qt(c),l=new Array(Number(u)+1).fill(i),g=Math.floor((e.BITS-1)/c)*c;let a=i;for(let w=g;w>=0;w-=c){l.fill(i);for(let p=0;p<o;p++){const y=r[p],d=Number(y>>BigInt(w)&u);l[d]=l[d].add(n[p])}let h=i;for(let p=l.length-1,y=i;p>0;p--)y=y.add(l[p]),h=h.add(y);if(a=a.add(h),w!==0)for(let p=0;p<c;p++)a=a.double()}return a}function _e(t,e,n){if(e){if(e.ORDER!==t)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return Cn(e),e}else return ht(t,{isLE:n})}function Yn(t,e,n={},r){if(r===void 0&&(r=t==="edwards"),!e||typeof e!="object")throw new Error(`expected valid ${t} CURVE object`);for(const c of["p","n","h"]){const u=e[c];if(!(typeof u=="bigint"&&u>qt))throw new Error(`CURVE.${c} must be positive bigint`)}const s=_e(e.p,n.Fp,r),o=_e(e.n,n.Fn,r),f=["Gx","Gy","a","d"];for(const c of f)if(!s.isValid(e[c]))throw new Error(`CURVE.${c} must be valid field element of CURVE.Fp`);return e=Object.freeze(Object.assign({},e)),{CURVE:e,Fp:s,Fn:o}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const nt=BigInt(0),L=BigInt(1),Dt=BigInt(2),Xn=BigInt(8);function jn(t,e,n,r){const s=t.sqr(n),o=t.sqr(r),i=t.add(t.mul(e.a,s),o),f=t.add(t.ONE,t.mul(e.d,t.mul(s,o)));return t.eql(i,f)}function $n(t,e={}){const n=Yn("edwards",t,e,e.FpFnLE),{Fp:r,Fn:s}=n;let o=n.CURVE;const{h:i}=o;xt(e,{},{uvRatio:"function"});const f=Dt<<BigInt(s.BYTES*8)-L,c=y=>r.create(y),u=e.uvRatio||((y,d)=>{try{return{isValid:!0,value:r.sqrt(r.div(y,d))}}catch{return{isValid:!1,value:nt}}});if(!jn(r,o,o.Gx,o.Gy))throw new Error("bad curve params: generator point");function l(y,d,B=!1){const b=B?L:nt;return It("coordinate "+y,d,b,f),d}function g(y){if(!(y instanceof h))throw new Error("ExtendedPoint expected")}const a=me((y,d)=>{const{X:B,Y:b,Z:A}=y,I=y.is0();d==null&&(d=I?Xn:r.inv(A));const N=c(B*d),U=c(b*d),q=r.mul(A,d);if(I)return{x:nt,y:L};if(q!==L)throw new Error("invZ was invalid");return{x:N,y:U}}),w=me(y=>{const{a:d,d:B}=o;if(y.is0())throw new Error("bad point: ZERO");const{X:b,Y:A,Z:I,T:N}=y,U=c(b*b),q=c(A*A),x=c(I*I),E=c(x*x),S=c(U*d),T=c(x*c(S+q)),_=c(E+c(B*c(U*q)));if(T!==_)throw new Error("bad point: equation left != right (1)");const v=c(b*A),O=c(I*N);if(v!==O)throw new Error("bad point: equation left != right (2)");return!0});class h{constructor(d,B,b,A){this.X=l("x",d),this.Y=l("y",B),this.Z=l("z",b,!0),this.T=l("t",A),Object.freeze(this)}static CURVE(){return o}static fromAffine(d){if(d instanceof h)throw new Error("extended point not allowed");const{x:B,y:b}=d||{};return l("x",B),l("y",b),new h(B,b,L,c(B*b))}static fromBytes(d,B=!1){const b=r.BYTES,{a:A,d:I}=o;d=we(St(d,b,"point")),$t(B,"zip215");const N=we(d),U=d[b-1];N[b-1]=U&-129;const q=st(N),x=B?f:r.ORDER;It("point.y",q,nt,x);const E=c(q*q),S=c(E-L),T=c(I*E-A);let{isValid:_,value:v}=u(S,T);if(!_)throw new Error("bad point: invalid y coordinate");const O=(v&L)===L,C=(U&128)!==0;if(!B&&v===nt&&C)throw new Error("bad point: x=0 and x_0=1");return C!==O&&(v=c(-v)),h.fromAffine({x:v,y:q})}static fromHex(d,B=!1){return h.fromBytes(X("point",d),B)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(d=8,B=!0){return p.createCache(this,d),B||this.multiply(Dt),this}assertValidity(){w(this)}equals(d){g(d);const{X:B,Y:b,Z:A}=this,{X:I,Y:N,Z:U}=d,q=c(B*U),x=c(I*A),E=c(b*U),S=c(N*A);return q===x&&E===S}is0(){return this.equals(h.ZERO)}negate(){return new h(c(-this.X),this.Y,this.Z,c(-this.T))}double(){const{a:d}=o,{X:B,Y:b,Z:A}=this,I=c(B*B),N=c(b*b),U=c(Dt*c(A*A)),q=c(d*I),x=B+b,E=c(c(x*x)-I-N),S=q+N,T=S-U,_=q-N,v=c(E*T),O=c(S*_),C=c(E*_),M=c(T*S);return new h(v,O,M,C)}add(d){g(d);const{a:B,d:b}=o,{X:A,Y:I,Z:N,T:U}=this,{X:q,Y:x,Z:E,T:S}=d,T=c(A*q),_=c(I*x),v=c(U*b*S),O=c(N*E),C=c((A+I)*(q+x)-T-_),M=O-v,V=O+v,R=c(_-B*T),$=c(C*M),G=c(V*R),gt=c(C*R),ct=c(M*V);return new h($,G,ct,gt)}subtract(d){return this.add(d.negate())}multiply(d){if(!s.isValidNot0(d))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:B,f:b}=p.cached(this,d,A=>vt(h,A));return vt(h,[B,b])[0]}multiplyUnsafe(d,B=h.ZERO){if(!s.isValid(d))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return d===nt?h.ZERO:this.is0()||d===L?this:p.unsafe(this,d,b=>vt(h,b),B)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}isTorsionFree(){return p.unsafe(this,o.n).is0()}toAffine(d){return a(this,d)}clearCofactor(){return i===L?this:this.multiplyUnsafe(i)}toBytes(){const{x:d,y:B}=this.toAffine(),b=r.toBytes(B);return b[b.length-1]|=d&L?128:0,b}toHex(){return Tt(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get ex(){return this.X}get ey(){return this.Y}get ez(){return this.Z}get et(){return this.T}static normalizeZ(d){return vt(h,d)}static msm(d,B){return ke(h,s,d,B)}_setWindowSize(d){this.precompute(d)}toRawBytes(){return this.toBytes()}}h.BASE=new h(o.Gx,o.Gy,L,c(o.Gx*o.Gy)),h.ZERO=new h(nt,L,L,nt),h.Fp=r,h.Fn=s;const p=new Dn(h,s.BITS);return h.BASE.precompute(8),h}class kn{constructor(e){this.ep=e}static fromBytes(e){be()}static fromHex(e){be()}get x(){return this.toAffine().x}get y(){return this.toAffine().y}clearCofactor(){return this}assertValidity(){this.ep.assertValidity()}toAffine(e){return this.ep.toAffine(e)}toHex(){return Tt(this.toBytes())}toString(){return this.toHex()}isTorsionFree(){return!0}isSmallOrder(){return!1}add(e){return this.assertSame(e),this.init(this.ep.add(e.ep))}subtract(e){return this.assertSame(e),this.init(this.ep.subtract(e.ep))}multiply(e){return this.init(this.ep.multiply(e))}multiplyUnsafe(e){return this.init(this.ep.multiplyUnsafe(e))}double(){return this.init(this.ep.double())}negate(){return this.init(this.ep.negate())}precompute(e,n){return this.init(this.ep.precompute(e,n))}toRawBytes(){return this.toBytes()}}function Gn(t,e,n={}){if(typeof e!="function")throw new Error('"hash" function param is required');xt(n,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:r}=n,{BASE:s,Fp:o,Fn:i}=t,f=n.randomBytes||Te,c=n.adjustScalarBytes||(x=>x),u=n.domain||((x,E,S)=>{if($t(S,"phflag"),E.length||S)throw new Error("Contexts/pre-hash are not supported");return x});function l(x){return i.create(st(x))}function g(x){const E=b.secretKey;x=X("private key",x,E);const S=X("hashed private key",e(x),2*E),T=c(S.slice(0,E)),_=S.slice(E,2*E),v=l(T);return{head:T,prefix:_,scalar:v}}function a(x){const{head:E,prefix:S,scalar:T}=g(x),_=s.multiply(T),v=_.toBytes();return{head:E,prefix:S,scalar:T,point:_,pointBytes:v}}function w(x){return a(x).pointBytes}function h(x=Uint8Array.of(),...E){const S=F(...E);return l(e(u(S,X("context",x),!!r)))}function p(x,E,S={}){x=X("message",x),r&&(x=r(x));const{prefix:T,scalar:_,pointBytes:v}=a(E),O=h(S.context,T,x),C=s.multiply(O).toBytes(),M=h(S.context,C,v,x),V=i.create(O+M*_);if(!i.isValid(V))throw new Error("sign failed: invalid s");const R=F(C,i.toBytes(V));return St(R,b.signature,"result")}const y={zip215:!0};function d(x,E,S,T=y){const{context:_,zip215:v}=T,O=b.signature;x=X("signature",x,O),E=X("message",E),S=X("publicKey",S,b.publicKey),v!==void 0&&$t(v,"zip215"),r&&(E=r(E));const C=O/2,M=x.subarray(0,C),V=st(x.subarray(C,O));let R,$,G;try{R=t.fromBytes(S,v),$=t.fromBytes(M,v),G=s.multiplyUnsafe(V)}catch{return!1}if(!v&&R.isSmallOrder())return!1;const gt=h(_,$.toBytes(),R.toBytes(),E);return $.add(R.multiplyUnsafe(gt)).subtract(G).clearCofactor().is0()}const B=o.BYTES,b={secretKey:B,publicKey:B,signature:2*B,seed:B};function A(x=f(b.seed)){return St(x,b.seed,"seed")}function I(x){const E=q.randomSecretKey(x);return{secretKey:E,publicKey:w(E)}}function N(x){return yt(x)&&x.length===i.BYTES}function U(x,E){try{return!!t.fromBytes(x,E)}catch{return!1}}const q={getExtendedPublicKey:a,randomSecretKey:A,isValidSecretKey:N,isValidPublicKey:U,toMontgomery(x){const{y:E}=t.fromBytes(x),S=b.publicKey,T=S===32;if(!T&&S!==57)throw new Error("only defined for 25519 and 448");const _=T?o.div(L+E,L-E):o.div(E-L,E+L);return o.toBytes(_)},toMontgomerySecret(x){const E=b.secretKey;St(x,E);const S=e(x.subarray(0,E));return c(S).subarray(0,E)},randomPrivateKey:A,precompute(x=8,E=t.BASE){return E.precompute(x,!1)}};return Object.freeze({keygen:I,getPublicKey:w,sign:p,verify:d,utils:q,Point:t,lengths:b})}function zn(t){const e={a:t.a,d:t.d,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},n=t.Fp,r=ht(e.n,t.nBitLength,!0),s={Fp:n,Fn:r,uvRatio:t.uvRatio},o={randomBytes:t.randomBytes,adjustScalarBytes:t.adjustScalarBytes,domain:t.domain,prehash:t.prehash,mapToCurve:t.mapToCurve};return{CURVE:e,curveOpts:s,hash:t.hash,eddsaOpts:o}}function Kn(t,e){const n=e.Point;return Object.assign({},e,{ExtendedPoint:n,CURVE:t,nBitLength:n.Fn.BITS,nByteLength:n.Fn.BYTES})}function te(t){const{CURVE:e,curveOpts:n,hash:r,eddsaOpts:s}=zn(t),o=$n(e,n),i=Gn(o,r,s);return Kn(t,i)}const Wn=Ze;function ot(t,e){if(mt(t),mt(e),t<0||t>=1<<8*e)throw new Error("invalid I2OSP input: "+t);const n=Array.from({length:e}).fill(0);for(let r=e-1;r>=0;r--)n[r]=t&255,t>>>=8;return new Uint8Array(n)}function Pn(t,e){const n=new Uint8Array(t.length);for(let r=0;r<t.length;r++)n[r]=t[r]^e[r];return n}function mt(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function Ge(t){if(!yt(t)&&typeof t!="string")throw new Error("DST must be Uint8Array or string");return typeof t=="string"?dt(t):t}function Gt(t,e,n,r){k(t),mt(n),e=Ge(e),e.length>255&&(e=r(F(dt("H2C-OVERSIZE-DST-"),e)));const{outputLen:s,blockLen:o}=r,i=Math.ceil(n/s);if(n>65535||i>255)throw new Error("expand_message_xmd: invalid lenInBytes");const f=F(e,ot(e.length,1)),c=ot(0,o),u=ot(n,2),l=new Array(i),g=r(F(c,t,u,ot(0,1),f));l[0]=r(F(g,ot(1,1),f));for(let w=1;w<=i;w++){const h=[Pn(g,l[w-1]),ot(w+1,1),f];l[w]=r(F(...h))}return F(...l).slice(0,n)}function Qn(t,e,n,r,s){if(k(t),mt(n),e=Ge(e),e.length>255){const o=Math.ceil(2*r/8);e=s.create({dkLen:o}).update(dt("H2C-OVERSIZE-DST-")).update(e).digest()}if(n>65535||e.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return s.create({dkLen:n}).update(t).update(ot(n,2)).update(e).update(ot(e.length,1)).digest()}function Yt(t,e,n){xt(n,{p:"bigint",m:"number",k:"number",hash:"function"});const{p:r,k:s,m:o,hash:i,expand:f,DST:c}=n;if(!In(n.hash))throw new Error("expected valid hash");k(t),mt(e);const u=r.toString(2).length,l=Math.ceil((u+s)/8),g=e*o*l;let a;if(f==="xmd")a=Gt(t,c,g,i);else if(f==="xof")a=Qn(t,c,g,s,i);else if(f==="_internal_pass")a=t;else throw new Error('expand must be "xmd" or "xof"');const w=new Array(e);for(let h=0;h<e;h++){const p=new Array(o);for(let y=0;y<o;y++){const d=l*(y+h*o),B=a.subarray(d,d+l);p[y]=Z(Wn(B),r)}w[h]=p}return w}const ze=dt("HashToScalar-");function Fn(t,e,n){if(typeof e!="function")throw new Error("mapToCurve() must be defined");function r(o){return t.fromAffine(e(o))}function s(o){const i=o.clearCofactor();return i.equals(t.ZERO)?t.ZERO:(i.assertValidity(),i)}return{defaults:n,hashToCurve(o,i){const f=Object.assign({},n,i),c=Yt(o,2,f),u=r(c[0]),l=r(c[1]);return s(u.add(l))},encodeToCurve(o,i){const f=n.encodeDST?{DST:n.encodeDST}:{},c=Object.assign({},n,f,i),u=Yt(o,1,c),l=r(u[0]);return s(l)},mapToCurve(o){if(!Array.isArray(o))throw new Error("expected array of bigints");for(const i of o)if(typeof i!="bigint")throw new Error("expected array of bigints");return s(r(o))},hashToScalar(o,i){const f=t.Fn.ORDER,c=Object.assign({},n,{p:f,m:1,DST:ze},i);return Yt(o,1,c)[0][0]}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const wt=BigInt(0),lt=BigInt(1),At=BigInt(2);function Jn(t){return xt(t,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...t})}function tr(t){const e=Jn(t),{P:n,type:r,adjustScalarBytes:s,powPminus2:o,randomBytes:i}=e,f=r==="x25519";if(!f&&r!=="x448")throw new Error("invalid type");const c=i||Te,u=f?255:448,l=f?32:56,g=BigInt(f?9:5),a=BigInt(f?121665:39081),w=f?At**BigInt(254):At**BigInt(447),h=f?BigInt(8)*At**BigInt(251)-lt:BigInt(4)*At**BigInt(445)-lt,p=w+h+lt,y=_=>Z(_,n),d=B(g);function B(_){return Le(y(_),l)}function b(_){const v=X("u coordinate",_,l);return f&&(v[31]&=127),y(st(v))}function A(_){return st(s(X("scalar",_,l)))}function I(_,v){const O=q(b(v),A(_));if(O===wt)throw new Error("invalid private or public key received");return B(O)}function N(_){return I(_,d)}function U(_,v,O){const C=y(_*(v-O));return v=y(v-C),O=y(O+C),{x_2:v,x_3:O}}function q(_,v){It("u",_,wt,n),It("scalar",v,w,p);const O=v,C=_;let M=lt,V=wt,R=_,$=lt,G=wt;for(let ct=BigInt(u-1);ct>=wt;ct--){const Ot=O>>ct&lt;G^=Ot,{x_2:M,x_3:R}=U(G,M,R),{x_2:V,x_3:$}=U(G,V,$),G=Ot;const Ut=M+V,Zt=y(Ut*Ut),Ct=M-V,oe=y(Ct*Ct),se=Zt-oe,rn=R+$,on=R-$,ie=y(on*Ut),ce=y(rn*Ct),fe=ie+ce,ae=ie-ce;R=y(fe*fe),$=y(C*y(ae*ae)),M=y(Zt*oe),V=y(se*(Zt+y(a*se)))}({x_2:M,x_3:R}=U(G,M,R)),{x_2:V,x_3:$}=U(G,V,$);const gt=o(V);return y(M*gt)}const x={secretKey:l,publicKey:l,seed:l},E=(_=c(l))=>(k(_,x.seed),_);function S(_){const v=E(_);return{secretKey:v,publicKey:N(v)}}return{keygen:S,getSharedSecret:(_,v)=>I(_,v),getPublicKey:_=>N(_),scalarMult:I,scalarMultBase:N,utils:{randomSecretKey:E,randomPrivateKey:E},GuBytes:d.slice(),lengths:x}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const er=BigInt(0),K=BigInt(1),Nt=BigInt(2),Ke=BigInt(3),We=BigInt(5),ee=BigInt(8),J=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),pt={p:J,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:ee,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function Pe(t){const e=BigInt(10),n=BigInt(20),r=BigInt(40),s=BigInt(80),o=J,f=t*t%o*t%o,c=z(f,Nt,o)*f%o,u=z(c,K,o)*t%o,l=z(u,We,o)*u%o,g=z(l,e,o)*l%o,a=z(g,n,o)*g%o,w=z(a,r,o)*a%o,h=z(w,s,o)*w%o,p=z(h,s,o)*w%o,y=z(p,e,o)*l%o;return{pow_p_5_8:z(y,Nt,o)*t%o,b2:f}}function Qe(t){return t[0]&=248,t[31]&=127,t[31]|=64,t}const zt=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function ne(t,e){const n=J,r=Z(e*e*e,n),s=Z(r*r*e,n),o=Pe(t*s).pow_p_5_8;let i=Z(t*r*o,n);const f=Z(e*i*i,n),c=i,u=Z(i*zt,n),l=f===t,g=f===Z(-t,n),a=f===Z(-t*zt,n);return l&&(i=c),(g||a)&&(i=u),rt(i,n)&&(i=Z(-i,n)),{isValid:l||g,value:i}}const m=ht(pt.p,{isLE:!0}),Fe=ht(pt.n,{isLE:!0}),re={...pt,Fp:m,hash:bt,adjustScalarBytes:Qe,uvRatio:ne},W=te(re);function Je(t,e,n){if(e.length>255)throw new Error("Context is too big");return F(dt("SigEd25519 no Ed25519 collisions"),new Uint8Array([n?1:0,e.length]),e,t)}const hr=te({...re,domain:Je}),gr=te(Object.assign({},re,{domain:Je,prehash:bt})),wr=(()=>{const t=m.ORDER;return tr({P:t,type:"x25519",powPminus2:e=>{const{pow_p_5_8:n,b2:r}=Pe(e);return Z(z(n,Ke,t)*r,t)},adjustScalarBytes:Qe})})(),nr=(J+Ke)/ee,rr=m.pow(Nt,nr),ve=m.sqrt(m.neg(m.ONE));function or(t){const e=(J-We)/ee,n=BigInt(486662);let r=m.sqr(t);r=m.mul(r,Nt);let s=m.add(r,m.ONE),o=m.neg(n),i=m.sqr(s),f=m.mul(i,s),c=m.mul(r,n);c=m.mul(c,o),c=m.add(c,i),c=m.mul(c,o);let u=m.sqr(f);i=m.sqr(u),u=m.mul(u,f),u=m.mul(u,c),i=m.mul(i,u);let l=m.pow(i,e);l=m.mul(l,u);let g=m.mul(l,ve);i=m.sqr(l),i=m.mul(i,f);let a=m.eql(i,c),w=m.cmov(g,l,a),h=m.mul(o,r),p=m.mul(l,t);p=m.mul(p,rr);let y=m.mul(p,ve),d=m.mul(c,r);i=m.sqr(p),i=m.mul(i,f);let B=m.eql(i,d),b=m.cmov(y,p,B);i=m.sqr(w),i=m.mul(i,f);let A=m.eql(i,c),I=m.cmov(h,o,A),N=m.cmov(b,w,A),U=m.isOdd(N);return N=m.cmov(N,m.neg(N),A!==U),{xMn:I,xMd:s,yMn:N,yMd:K}}const sr=Rn(m,m.neg(BigInt(486664)));function ir(t){const{xMn:e,xMd:n,yMn:r,yMd:s}=or(t);let o=m.mul(e,s);o=m.mul(o,sr);let i=m.mul(n,r),f=m.sub(e,n),c=m.add(e,n),u=m.mul(i,c),l=m.eql(u,m.ZERO);o=m.cmov(o,m.ZERO,l),i=m.cmov(i,m.ONE,l),f=m.cmov(f,m.ONE,l),c=m.cmov(c,m.ONE,l);const[g,a]=Jt(m,[i,c],!0);return{x:m.mul(o,g),y:m.mul(f,a)}}const tn=Fn(W.Point,t=>ir(t[0]),{DST:"edwards25519_XMD:SHA-512_ELL2_RO_",encodeDST:"edwards25519_XMD:SHA-512_ELL2_NU_",p:J,m:1,k:128,expand:"xmd",hash:bt}),Kt=zt,cr=BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),fr=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),ar=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),ur=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),Ae=t=>ne(K,t),lr=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),Wt=t=>W.Point.Fp.create(st(t)&lr);function Se(t){const{d:e}=pt,n=J,r=d=>m.create(d),s=r(Kt*t*t),o=r((s+K)*ar);let i=BigInt(-1);const f=r((i-e*s)*r(s+e));let{isValid:c,value:u}=ne(o,f),l=r(u*t);rt(l,n)||(l=r(-l)),c||(u=l),c||(i=s);const g=r(i*(s-K)*ur-f),a=u*u,w=r((u+u)*f),h=r(g*cr),p=r(K-a),y=r(K+a);return new W.Point(r(w*y),r(p*h),r(h*y),r(w*p))}function en(t){k(t,64);const e=Wt(t.subarray(0,32)),n=Se(e),r=Wt(t.subarray(32,64)),s=Se(r);return new H(n.add(s))}class H extends kn{constructor(e){super(e)}static fromAffine(e){return new H(W.Point.fromAffine(e))}assertSame(e){if(!(e instanceof H))throw new Error("RistrettoPoint expected")}init(e){return new H(e)}static hashToCurve(e){return en(X("ristrettoHash",e,64))}static fromBytes(e){k(e,32);const{a:n,d:r}=pt,s=J,o=A=>m.create(A),i=Wt(e);if(!vn(m.toBytes(i),e)||rt(i,s))throw new Error("invalid ristretto255 encoding 1");const f=o(i*i),c=o(K+n*f),u=o(K-n*f),l=o(c*c),g=o(u*u),a=o(n*r*l-g),{isValid:w,value:h}=Ae(o(a*g)),p=o(h*u),y=o(h*p*a);let d=o((i+i)*p);rt(d,s)&&(d=o(-d));const B=o(c*y),b=o(d*B);if(!w||rt(b,s)||B===er)throw new Error("invalid ristretto255 encoding 2");return new H(new W.Point(d,B,K,b))}static fromHex(e){return H.fromBytes(X("ristrettoHex",e,32))}static msm(e,n){return ke(H,W.Point.Fn,e,n)}toBytes(){let{X:e,Y:n,Z:r,T:s}=this.ep;const o=J,i=y=>m.create(y),f=i(i(r+n)*i(r-n)),c=i(e*n),u=i(c*c),{value:l}=Ae(i(f*u)),g=i(l*f),a=i(l*c),w=i(g*a*s);let h;if(rt(s*w,o)){let y=i(n*Kt),d=i(e*Kt);e=y,n=d,h=i(g*fr)}else h=a;rt(e*w,o)&&(n=i(-n));let p=i((r-n)*h);return rt(p,o)&&(p=i(-p)),m.toBytes(p)}equals(e){this.assertSame(e);const{X:n,Y:r}=this.ep,{X:s,Y:o}=e.ep,i=u=>m.create(u),f=i(n*o)===i(r*s),c=i(r*o)===i(n*s);return f||c}is0(){return this.equals(H.ZERO)}}H.BASE=new H(W.Point.BASE);H.ZERO=new H(W.Point.ZERO);H.Fp=m;H.Fn=Fe;const br={Point:H},nn={hashToCurve(t,e){const n=(e==null?void 0:e.DST)||"ristretto255_XMD:SHA-512_R255MAP_RO_",r=Gt(t,n,64,bt);return en(r)},hashToScalar(t,e={DST:ze}){const n=Gt(t,e.DST,64,bt);return Fe.create(st(n))}},mr=["0100000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a","0000000000000000000000000000000000000000000000000000000000000080","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05","ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85","0000000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"];function dr(t){return W.utils.toMontgomery(X("pub",t))}const yr=dr;function xr(t){return W.utils.toMontgomerySecret(X("pub",t))}const pr=H,Br=tn.hashToCurve,Er=tn.encodeToCurve,_r=nn.hashToCurve,vr=nn.hashToCurve;export{mr as ED25519_TORSION_SUBGROUP,pr as RistrettoPoint,W as ed25519,tn as ed25519_hasher,hr as ed25519ctx,gr as ed25519ph,yr as edwardsToMontgomery,xr as edwardsToMontgomeryPriv,dr as edwardsToMontgomeryPub,Er as encodeToCurve,Br as hashToCurve,_r as hashToRistretto255,vr as hash_to_ristretto255,br as ristretto255,nn as ristretto255_hasher,wr as x25519};
