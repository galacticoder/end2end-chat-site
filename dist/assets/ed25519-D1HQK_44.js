import{h as un,i as pt,d as nt,e as Et,f as Xn,j as dn,k as P,u as at,s as ct}from"./index-lmufJFxl.js";/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Ut=BigInt(0),Ot=BigInt(1);function Tt(t,n=""){if(typeof t!="boolean"){const e=n&&`"${n}"`;throw new Error(e+"expected boolean, got type="+typeof t)}return t}function wt(t,n,e=""){const r=pt(t),c=t==null?void 0:t.length,o=n!==void 0;if(!r||o&&c!==n){const i=e&&`"${e}" `,f=o?` of length ${n}`:"",s=r?`length=${c}`:`type=${typeof t}`;throw new Error(i+"expected Uint8Array"+f+", got "+s)}return t}function ln(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?Ut:BigInt("0x"+t)}function hn(t){return ln(Et(t))}function F(t){return nt(t),ln(Et(Uint8Array.from(t).reverse()))}function wn(t,n){return un(t.toString(16).padStart(n*2,"0"))}function mn(t,n){return wn(t,n).reverse()}function j(t,n,e){let r;if(typeof n=="string")try{r=un(n)}catch(o){throw new Error(t+" must be hex string or Uint8Array, cause: "+o)}else if(pt(n))r=Uint8Array.from(n);else throw new Error(t+" must be hex string or Uint8Array");const c=r.length;if(typeof e=="number"&&c!==e)throw new Error(t+" of length "+e+" expected, got "+c);return r}function Vn(t,n){if(t.length!==n.length)return!1;let e=0;for(let r=0;r<t.length;r++)e|=t[r]^n[r];return e===0}function Wt(t){return Uint8Array.from(t)}const vt=t=>typeof t=="bigint"&&Ut<=t;function jn(t,n,e){return vt(t)&&vt(n)&&vt(e)&&n<=t&&t<e}function mt(t,n,e,r){if(!jn(n,e,r))throw new Error("expected valid "+t+": "+e+" <= n < "+r+", got "+n)}function $n(t){let n;for(n=0;t>Ut;t>>=Ot,n+=1);return n}const Yt=t=>(Ot<<BigInt(t))-Ot;function zn(t){return typeof t=="function"&&Number.isSafeInteger(t.outputLen)}function ut(t,n,e={}){if(!t||typeof t!="object")throw new Error("expected valid options object");function r(c,o,i){const f=t[c];if(i&&f===void 0)return;const s=typeof f;if(s!==o||f===null)throw new Error(`param "${c}" is invalid: expected ${o}, got ${s}`)}Object.entries(n).forEach(([c,o])=>r(c,o,!1)),Object.entries(e).forEach(([c,o])=>r(c,o,!0))}const Jt=()=>{throw new Error("not implemented")};function Ft(t){const n=new WeakMap;return(e,...r)=>{const c=n.get(e);if(c!==void 0)return c;const o=t(e,...r);return n.set(e,o),o}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const $=BigInt(0),V=BigInt(1),tt=BigInt(2),gn=BigInt(3),yn=BigInt(4),pn=BigInt(5),Dn=BigInt(7),En=BigInt(8),kn=BigInt(9),Bn=BigInt(16);function R(t,n){const e=t%n;return e>=$?e:n+e}function k(t,n,e){let r=t;for(;n-- >$;)r*=r,r%=e;return r}function tn(t,n){if(t===$)throw new Error("invert: expected non-zero number");if(n<=$)throw new Error("invert: expected positive modulus, got "+n);let e=R(t,n),r=n,c=$,o=V;for(;e!==$;){const f=r/e,s=r%e,d=c-o*f;r=e,e=s,c=o,o=d}if(r!==V)throw new Error("invert: does not exist");return R(c,n)}function Xt(t,n,e){if(!t.eql(t.sqr(n),e))throw new Error("Cannot find square root")}function _n(t,n){const e=(t.ORDER+V)/yn,r=t.pow(n,e);return Xt(t,r,n),r}function Kn(t,n){const e=(t.ORDER-pn)/En,r=t.mul(n,tt),c=t.pow(r,e),o=t.mul(n,c),i=t.mul(t.mul(o,tt),c),f=t.mul(o,t.sub(i,t.ONE));return Xt(t,f,n),f}function Gn(t){const n=ot(t),e=bn(t),r=e(n,n.neg(n.ONE)),c=e(n,r),o=e(n,n.neg(r)),i=(t+Dn)/Bn;return(f,s)=>{let d=f.pow(s,i),u=f.mul(d,r);const p=f.mul(d,c),a=f.mul(d,o),m=f.eql(f.sqr(u),s),w=f.eql(f.sqr(p),s);d=f.cmov(d,u,m),u=f.cmov(a,p,w);const E=f.eql(f.sqr(u),s),g=f.cmov(d,u,E);return Xt(f,g,s),g}}function bn(t){if(t<gn)throw new Error("sqrt is not defined for small field");let n=t-V,e=0;for(;n%tt===$;)n/=tt,e++;let r=tt;const c=ot(t);for(;nn(c,r)===1;)if(r++>1e3)throw new Error("Cannot find square root: probably non-prime P");if(e===1)return _n;let o=c.pow(r,n);const i=(n+V)/tt;return function(s,d){if(s.is0(d))return d;if(nn(s,d)!==1)throw new Error("Cannot find square root");let u=e,p=s.mul(s.ONE,o),a=s.pow(d,n),m=s.pow(d,i);for(;!s.eql(a,s.ONE);){if(s.is0(a))return s.ZERO;let w=1,E=s.sqr(a);for(;!s.eql(E,s.ONE);)if(w++,E=s.sqr(E),w===u)throw new Error("Cannot find square root");const g=V<<BigInt(u-w-1),l=s.pow(p,g);u=w,p=s.sqr(l),a=s.mul(a,p),m=s.mul(m,l)}return m}}function Pn(t){return t%yn===gn?_n:t%En===pn?Kn:t%Bn===kn?Gn(t):bn(t)}const W=(t,n)=>(R(t,n)&V)===V,Hn=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function Qn(t){const n={ORDER:"bigint",MASK:"bigint",BYTES:"number",BITS:"number"},e=Hn.reduce((r,c)=>(r[c]="function",r),n);return ut(t,e),t}function Wn(t,n,e){if(e<$)throw new Error("invalid exponent, negatives unsupported");if(e===$)return t.ONE;if(e===V)return n;let r=t.ONE,c=n;for(;e>$;)e&V&&(r=t.mul(r,c)),c=t.sqr(c),e>>=V;return r}function Vt(t,n,e=!1){const r=new Array(n.length).fill(e?t.ZERO:void 0),c=n.reduce((i,f,s)=>t.is0(f)?i:(r[s]=i,t.mul(i,f)),t.ONE),o=t.inv(c);return n.reduceRight((i,f,s)=>t.is0(f)?i:(r[s]=t.mul(i,r[s]),t.mul(i,f)),o),r}function nn(t,n){const e=(t.ORDER-V)/tt,r=t.pow(n,e),c=t.eql(r,t.ONE),o=t.eql(r,t.ZERO),i=t.eql(r,t.neg(t.ONE));if(!c&&!o&&!i)throw new Error("invalid Legendre symbol result");return c?1:o?0:-1}function Jn(t,n){n!==void 0&&Xn(n);const e=n!==void 0?n:t.toString(2).length,r=Math.ceil(e/8);return{nBitLength:e,nByteLength:r}}function ot(t,n,e=!1,r={}){if(t<=$)throw new Error("invalid field: expected ORDER > 0, got "+t);let c,o,i=!1,f;if(typeof n=="object"&&n!=null){if(r.sqrt||e)throw new Error("cannot specify opts in two arguments");const a=n;a.BITS&&(c=a.BITS),a.sqrt&&(o=a.sqrt),typeof a.isLE=="boolean"&&(e=a.isLE),typeof a.modFromBytes=="boolean"&&(i=a.modFromBytes),f=a.allowedLengths}else typeof n=="number"&&(c=n),r.sqrt&&(o=r.sqrt);const{nBitLength:s,nByteLength:d}=Jn(t,c);if(d>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let u;const p=Object.freeze({ORDER:t,isLE:e,BITS:s,BYTES:d,MASK:Yt(s),ZERO:$,ONE:V,allowedLengths:f,create:a=>R(a,t),isValid:a=>{if(typeof a!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof a);return $<=a&&a<t},is0:a=>a===$,isValidNot0:a=>!p.is0(a)&&p.isValid(a),isOdd:a=>(a&V)===V,neg:a=>R(-a,t),eql:(a,m)=>a===m,sqr:a=>R(a*a,t),add:(a,m)=>R(a+m,t),sub:(a,m)=>R(a-m,t),mul:(a,m)=>R(a*m,t),pow:(a,m)=>Wn(p,a,m),div:(a,m)=>R(a*tn(m,t),t),sqrN:a=>a*a,addN:(a,m)=>a+m,subN:(a,m)=>a-m,mulN:(a,m)=>a*m,inv:a=>tn(a,t),sqrt:o||(a=>(u||(u=Pn(t)),u(p,a))),toBytes:a=>e?mn(a,d):wn(a,d),fromBytes:(a,m=!0)=>{if(f){if(!f.includes(a.length)||a.length>d)throw new Error("Field.fromBytes: expected "+f+" bytes, got "+a.length);const E=new Uint8Array(d);E.set(a,e?0:E.length-a.length),a=E}if(a.length!==d)throw new Error("Field.fromBytes: expected "+d+" bytes, got "+a.length);let w=e?F(a):hn(a);if(i&&(w=R(w,t)),!m&&!p.isValid(w))throw new Error("invalid field element: outside of range 0..ORDER");return w},invertBatch:a=>Vt(p,a),cmov:(a,m,w)=>w?m:a});return Object.freeze(p)}function Fn(t,n){if(!t.isOdd)throw new Error("Field doesn't have isOdd");const e=t.sqrt(n);return t.isOdd(e)?t.neg(e):e}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const gt=BigInt(0),Zt=BigInt(1);function en(t,n){const e=n.negate();return t?e:n}function lt(t,n){const e=Vt(t.Fp,n.map(r=>r.Z));return n.map((r,c)=>t.fromAffine(r.toAffine(e[c])))}function xn(t,n){if(!Number.isSafeInteger(t)||t<=0||t>n)throw new Error("invalid window size, expected [1.."+n+"], got W="+t)}function St(t,n){xn(t,n);const e=Math.ceil(n/t)+1,r=2**(t-1),c=2**t,o=Yt(t),i=BigInt(t);return{windows:e,windowSize:r,mask:o,maxNumber:c,shiftBy:i}}function rn(t,n,e){const{windowSize:r,mask:c,maxNumber:o,shiftBy:i}=e;let f=Number(t&c),s=t>>i;f>r&&(f-=o,s+=Zt);const d=n*r,u=d+Math.abs(f)-1,p=f===0,a=f<0,m=n%2!==0;return{nextN:s,offset:u,isZero:p,isNeg:a,isNegF:m,offsetF:d}}function te(t,n){if(!Array.isArray(t))throw new Error("array expected");t.forEach((e,r)=>{if(!(e instanceof n))throw new Error("invalid point at index "+r)})}function ne(t,n){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((e,r)=>{if(!n.isValid(e))throw new Error("invalid scalar at index "+r)})}const It=new WeakMap,vn=new WeakMap;function At(t){return vn.get(t)||1}function on(t){if(t!==gt)throw new Error("invalid wNAF")}class ee{constructor(n,e){this.BASE=n.BASE,this.ZERO=n.ZERO,this.Fn=n.Fn,this.bits=e}_unsafeLadder(n,e,r=this.ZERO){let c=n;for(;e>gt;)e&Zt&&(r=r.add(c)),c=c.double(),e>>=Zt;return r}precomputeWindow(n,e){const{windows:r,windowSize:c}=St(e,this.bits),o=[];let i=n,f=i;for(let s=0;s<r;s++){f=i,o.push(f);for(let d=1;d<c;d++)f=f.add(i),o.push(f);i=f.double()}return o}wNAF(n,e,r){if(!this.Fn.isValid(r))throw new Error("invalid scalar");let c=this.ZERO,o=this.BASE;const i=St(n,this.bits);for(let f=0;f<i.windows;f++){const{nextN:s,offset:d,isZero:u,isNeg:p,isNegF:a,offsetF:m}=rn(r,f,i);r=s,u?o=o.add(en(a,e[m])):c=c.add(en(p,e[d]))}return on(r),{p:c,f:o}}wNAFUnsafe(n,e,r,c=this.ZERO){const o=St(n,this.bits);for(let i=0;i<o.windows&&r!==gt;i++){const{nextN:f,offset:s,isZero:d,isNeg:u}=rn(r,i,o);if(r=f,!d){const p=e[s];c=c.add(u?p.negate():p)}}return on(r),c}getPrecomputes(n,e,r){let c=It.get(e);return c||(c=this.precomputeWindow(e,n),n!==1&&(typeof r=="function"&&(c=r(c)),It.set(e,c))),c}cached(n,e,r){const c=At(n);return this.wNAF(c,this.getPrecomputes(c,n,r),e)}unsafe(n,e,r,c){const o=At(n);return o===1?this._unsafeLadder(n,e,c):this.wNAFUnsafe(o,this.getPrecomputes(o,n,r),e,c)}createCache(n,e){xn(e,this.bits),vn.set(n,e),It.delete(n)}hasCache(n){return At(n)!==1}}function Sn(t,n,e,r){te(e,t),ne(r,n);const c=e.length,o=r.length;if(c!==o)throw new Error("arrays of points and scalars must have equal length");const i=t.ZERO,f=$n(BigInt(c));let s=1;f>12?s=f-3:f>4?s=f-2:f>0&&(s=2);const d=Yt(s),u=new Array(Number(d)+1).fill(i),p=Math.floor((n.BITS-1)/s)*s;let a=i;for(let m=p;m>=0;m-=s){u.fill(i);for(let E=0;E<o;E++){const g=r[E],l=Number(g>>BigInt(m)&d);u[l]=u[l].add(e[E])}let w=i;for(let E=u.length-1,g=i;E>0;E--)g=g.add(u[E]),w=w.add(g);if(a=a.add(w),m!==0)for(let E=0;E<s;E++)a=a.double()}return a}function sn(t,n,e){if(n){if(n.ORDER!==t)throw new Error("Field.ORDER must match order: Fp == p, Fn == n");return Qn(n),n}else return ot(t,{isLE:e})}function re(t,n,e={},r){if(r===void 0&&(r=t==="edwards"),!n||typeof n!="object")throw new Error(`expected valid ${t} CURVE object`);for(const s of["p","n","h"]){const d=n[s];if(!(typeof d=="bigint"&&d>gt))throw new Error(`CURVE.${s} must be positive bigint`)}const c=sn(n.p,e.Fp,r),o=sn(n.n,e.Fn,r),f=["Gx","Gy","a","d"];for(const s of f)if(!c.isValid(n[s]))throw new Error(`CURVE.${s} must be valid field element of CURVE.Fp`);return n=Object.freeze(Object.assign({},n)),{CURVE:n,Fp:c,Fn:o}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const Q=BigInt(0),C=BigInt(1),qt=BigInt(2),oe=BigInt(8);function se(t,n,e,r){const c=t.sqr(e),o=t.sqr(r),i=t.add(t.mul(n.a,c),o),f=t.add(t.ONE,t.mul(n.d,t.mul(c,o)));return t.eql(i,f)}function ie(t,n={}){const e=re("edwards",t,n,n.FpFnLE),{Fp:r,Fn:c}=e;let o=e.CURVE;const{h:i}=o;ut(n,{},{uvRatio:"function"});const f=qt<<BigInt(c.BYTES*8)-C,s=g=>r.create(g),d=n.uvRatio||((g,l)=>{try{return{isValid:!0,value:r.sqrt(r.div(g,l))}}catch{return{isValid:!1,value:Q}}});if(!se(r,o,o.Gx,o.Gy))throw new Error("bad curve params: generator point");function u(g,l,B=!1){const b=B?C:Q;return mt("coordinate "+g,l,b,f),l}function p(g){if(!(g instanceof w))throw new Error("ExtendedPoint expected")}const a=Ft((g,l)=>{const{X:B,Y:b,Z:I}=g,N=g.is0();l==null&&(l=N?oe:r.inv(I));const A=s(B*l),O=s(b*l),Z=r.mul(I,l);if(N)return{x:Q,y:C};if(Z!==C)throw new Error("invZ was invalid");return{x:A,y:O}}),m=Ft(g=>{const{a:l,d:B}=o;if(g.is0())throw new Error("bad point: ZERO");const{X:b,Y:I,Z:N,T:A}=g,O=s(b*b),Z=s(I*I),y=s(N*N),_=s(y*y),S=s(O*l),T=s(y*s(S+Z)),x=s(_+s(B*s(O*Z)));if(T!==x)throw new Error("bad point: equation left != right (1)");const v=s(b*I),q=s(N*A);if(v!==q)throw new Error("bad point: equation left != right (2)");return!0});class w{constructor(l,B,b,I){this.X=u("x",l),this.Y=u("y",B),this.Z=u("z",b,!0),this.T=u("t",I),Object.freeze(this)}static CURVE(){return o}static fromAffine(l){if(l instanceof w)throw new Error("extended point not allowed");const{x:B,y:b}=l||{};return u("x",B),u("y",b),new w(B,b,C,s(B*b))}static fromBytes(l,B=!1){const b=r.BYTES,{a:I,d:N}=o;l=Wt(wt(l,b,"point")),Tt(B,"zip215");const A=Wt(l),O=l[b-1];A[b-1]=O&-129;const Z=F(A),y=B?f:r.ORDER;mt("point.y",Z,Q,y);const _=s(Z*Z),S=s(_-C),T=s(N*_-I);let{isValid:x,value:v}=d(S,T);if(!x)throw new Error("bad point: invalid y coordinate");const q=(v&C)===C,M=(O&128)!==0;if(!B&&v===Q&&M)throw new Error("bad point: x=0 and x_0=1");return M!==q&&(v=s(-v)),w.fromAffine({x:v,y:Z})}static fromHex(l,B=!1){return w.fromBytes(j("point",l),B)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}precompute(l=8,B=!0){return E.createCache(this,l),B||this.multiply(qt),this}assertValidity(){m(this)}equals(l){p(l);const{X:B,Y:b,Z:I}=this,{X:N,Y:A,Z:O}=l,Z=s(B*O),y=s(N*I),_=s(b*O),S=s(A*I);return Z===y&&_===S}is0(){return this.equals(w.ZERO)}negate(){return new w(s(-this.X),this.Y,this.Z,s(-this.T))}double(){const{a:l}=o,{X:B,Y:b,Z:I}=this,N=s(B*B),A=s(b*b),O=s(qt*s(I*I)),Z=s(l*N),y=B+b,_=s(s(y*y)-N-A),S=Z+A,T=S-O,x=Z-A,v=s(_*T),q=s(S*x),M=s(_*x),L=s(T*S);return new w(v,q,L,M)}add(l){p(l);const{a:B,d:b}=o,{X:I,Y:N,Z:A,T:O}=this,{X:Z,Y:y,Z:_,T:S}=l,T=s(I*Z),x=s(N*y),v=s(O*b*S),q=s(A*_),M=s((I+N)*(Z+y)-T-x),L=q-v,X=q+v,U=s(x-B*T),z=s(M*L),D=s(X*U),st=s(M*U),et=s(L*X);return new w(z,D,et,st)}subtract(l){return this.add(l.negate())}multiply(l){if(!c.isValidNot0(l))throw new Error("invalid scalar: expected 1 <= sc < curve.n");const{p:B,f:b}=E.cached(this,l,I=>lt(w,I));return lt(w,[B,b])[0]}multiplyUnsafe(l,B=w.ZERO){if(!c.isValid(l))throw new Error("invalid scalar: expected 0 <= sc < curve.n");return l===Q?w.ZERO:this.is0()||l===C?this:E.unsafe(this,l,b=>lt(w,b),B)}isSmallOrder(){return this.multiplyUnsafe(i).is0()}isTorsionFree(){return E.unsafe(this,o.n).is0()}toAffine(l){return a(this,l)}clearCofactor(){return i===C?this:this.multiplyUnsafe(i)}toBytes(){const{x:l,y:B}=this.toAffine(),b=r.toBytes(B);return b[b.length-1]|=l&C?128:0,b}toHex(){return Et(this.toBytes())}toString(){return`<Point ${this.is0()?"ZERO":this.toHex()}>`}get ex(){return this.X}get ey(){return this.Y}get ez(){return this.Z}get et(){return this.T}static normalizeZ(l){return lt(w,l)}static msm(l,B){return Sn(w,c,l,B)}_setWindowSize(l){this.precompute(l)}toRawBytes(){return this.toBytes()}}w.BASE=new w(o.Gx,o.Gy,C,s(o.Gx*o.Gy)),w.ZERO=new w(Q,C,C,Q),w.Fp=r,w.Fn=c;const E=new ee(w,c.BITS);return w.BASE.precompute(8),w}class ce{constructor(n){this.ep=n}static fromBytes(n){Jt()}static fromHex(n){Jt()}get x(){return this.toAffine().x}get y(){return this.toAffine().y}clearCofactor(){return this}assertValidity(){this.ep.assertValidity()}toAffine(n){return this.ep.toAffine(n)}toHex(){return Et(this.toBytes())}toString(){return this.toHex()}isTorsionFree(){return!0}isSmallOrder(){return!1}add(n){return this.assertSame(n),this.init(this.ep.add(n.ep))}subtract(n){return this.assertSame(n),this.init(this.ep.subtract(n.ep))}multiply(n){return this.init(this.ep.multiply(n))}multiplyUnsafe(n){return this.init(this.ep.multiplyUnsafe(n))}double(){return this.init(this.ep.double())}negate(){return this.init(this.ep.negate())}precompute(n,e){return this.init(this.ep.precompute(n,e))}toRawBytes(){return this.toBytes()}}function fe(t,n,e={}){if(typeof n!="function")throw new Error('"hash" function param is required');ut(e,{},{adjustScalarBytes:"function",randomBytes:"function",domain:"function",prehash:"function",mapToCurve:"function"});const{prehash:r}=e,{BASE:c,Fp:o,Fn:i}=t,f=e.randomBytes||dn,s=e.adjustScalarBytes||(y=>y),d=e.domain||((y,_,S)=>{if(Tt(S,"phflag"),_.length||S)throw new Error("Contexts/pre-hash are not supported");return y});function u(y){return i.create(F(y))}function p(y){const _=b.secretKey;y=j("private key",y,_);const S=j("hashed private key",n(y),2*_),T=s(S.slice(0,_)),x=S.slice(_,2*_),v=u(T);return{head:T,prefix:x,scalar:v}}function a(y){const{head:_,prefix:S,scalar:T}=p(y),x=c.multiply(T),v=x.toBytes();return{head:_,prefix:S,scalar:T,point:x,pointBytes:v}}function m(y){return a(y).pointBytes}function w(y=Uint8Array.of(),..._){const S=P(..._);return u(n(d(S,j("context",y),!!r)))}function E(y,_,S={}){y=j("message",y),r&&(y=r(y));const{prefix:T,scalar:x,pointBytes:v}=a(_),q=w(S.context,T,y),M=c.multiply(q).toBytes(),L=w(S.context,M,v,y),X=i.create(q+L*x);if(!i.isValid(X))throw new Error("sign failed: invalid s");const U=P(M,i.toBytes(X));return wt(U,b.signature,"result")}const g={zip215:!0};function l(y,_,S,T=g){const{context:x,zip215:v}=T,q=b.signature;y=j("signature",y,q),_=j("message",_),S=j("publicKey",S,b.publicKey),v!==void 0&&Tt(v,"zip215"),r&&(_=r(_));const M=q/2,L=y.subarray(0,M),X=F(y.subarray(M,q));let U,z,D;try{U=t.fromBytes(S,v),z=t.fromBytes(L,v),D=c.multiplyUnsafe(X)}catch{return!1}if(!v&&U.isSmallOrder())return!1;const st=w(x,z.toBytes(),U.toBytes(),_);return z.add(U.multiplyUnsafe(st)).subtract(D).clearCofactor().is0()}const B=o.BYTES,b={secretKey:B,publicKey:B,signature:2*B,seed:B};function I(y=f(b.seed)){return wt(y,b.seed,"seed")}function N(y){const _=Z.randomSecretKey(y);return{secretKey:_,publicKey:m(_)}}function A(y){return pt(y)&&y.length===i.BYTES}function O(y,_){try{return!!t.fromBytes(y,_)}catch{return!1}}const Z={getExtendedPublicKey:a,randomSecretKey:I,isValidSecretKey:A,isValidPublicKey:O,toMontgomery(y){const{y:_}=t.fromBytes(y),S=b.publicKey,T=S===32;if(!T&&S!==57)throw new Error("only defined for 25519 and 448");const x=T?o.div(C+_,C-_):o.div(_-C,_+C);return o.toBytes(x)},toMontgomerySecret(y){const _=b.secretKey;wt(y,_);const S=n(y.subarray(0,_));return s(S).subarray(0,_)},randomPrivateKey:I,precompute(y=8,_=t.BASE){return _.precompute(y,!1)}};return Object.freeze({keygen:N,getPublicKey:m,sign:E,verify:l,utils:Z,Point:t,lengths:b})}function ae(t){const n={a:t.a,d:t.d,p:t.Fp.ORDER,n:t.n,h:t.h,Gx:t.Gx,Gy:t.Gy},e=t.Fp,r=ot(n.n,t.nBitLength,!0),c={Fp:e,Fn:r,uvRatio:t.uvRatio},o={randomBytes:t.randomBytes,adjustScalarBytes:t.adjustScalarBytes,domain:t.domain,prehash:t.prehash,mapToCurve:t.mapToCurve};return{CURVE:n,curveOpts:c,hash:t.hash,eddsaOpts:o}}function ue(t,n){const e=n.Point;return Object.assign({},n,{ExtendedPoint:e,CURVE:t,nBitLength:e.Fn.BITS,nByteLength:e.Fn.BYTES})}function jt(t){const{CURVE:n,curveOpts:e,hash:r,eddsaOpts:c}=ae(t),o=ie(n,e),i=fe(o,r,c);return ue(t,i)}const de=hn;function J(t,n){if(ft(t),ft(n),t<0||t>=1<<8*n)throw new Error("invalid I2OSP input: "+t);const e=Array.from({length:n}).fill(0);for(let r=n-1;r>=0;r--)e[r]=t&255,t>>>=8;return new Uint8Array(e)}function le(t,n){const e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t[r]^n[r];return e}function ft(t){if(!Number.isSafeInteger(t))throw new Error("number expected")}function In(t){if(!pt(t)&&typeof t!="string")throw new Error("DST must be Uint8Array or string");return typeof t=="string"?at(t):t}function Rt(t,n,e,r){nt(t),ft(e),n=In(n),n.length>255&&(n=r(P(at("H2C-OVERSIZE-DST-"),n)));const{outputLen:c,blockLen:o}=r,i=Math.ceil(e/c);if(e>65535||i>255)throw new Error("expand_message_xmd: invalid lenInBytes");const f=P(n,J(n.length,1)),s=J(0,o),d=J(e,2),u=new Array(i),p=r(P(s,t,d,J(0,1),f));u[0]=r(P(p,J(1,1),f));for(let m=1;m<=i;m++){const w=[le(p,u[m-1]),J(m+1,1),f];u[m]=r(P(...w))}return P(...u).slice(0,e)}function he(t,n,e,r,c){if(nt(t),ft(e),n=In(n),n.length>255){const o=Math.ceil(2*r/8);n=c.create({dkLen:o}).update(at("H2C-OVERSIZE-DST-")).update(n).digest()}if(e>65535||n.length>255)throw new Error("expand_message_xof: invalid lenInBytes");return c.create({dkLen:e}).update(t).update(J(e,2)).update(n).update(J(n.length,1)).digest()}function Nt(t,n,e){ut(e,{p:"bigint",m:"number",k:"number",hash:"function"});const{p:r,k:c,m:o,hash:i,expand:f,DST:s}=e;if(!zn(e.hash))throw new Error("expected valid hash");nt(t),ft(n);const d=r.toString(2).length,u=Math.ceil((d+c)/8),p=n*o*u;let a;if(f==="xmd")a=Rt(t,s,p,i);else if(f==="xof")a=he(t,s,p,c,i);else if(f==="_internal_pass")a=t;else throw new Error('expand must be "xmd" or "xof"');const m=new Array(n);for(let w=0;w<n;w++){const E=new Array(o);for(let g=0;g<o;g++){const l=u*(g+w*o),B=a.subarray(l,l+u);E[g]=R(de(B),r)}m[w]=E}return m}const An=at("HashToScalar-");function we(t,n,e){if(typeof n!="function")throw new Error("mapToCurve() must be defined");function r(o){return t.fromAffine(n(o))}function c(o){const i=o.clearCofactor();return i.equals(t.ZERO)?t.ZERO:(i.assertValidity(),i)}return{defaults:e,hashToCurve(o,i){const f=Object.assign({},e,i),s=Nt(o,2,f),d=r(s[0]),u=r(s[1]);return c(d.add(u))},encodeToCurve(o,i){const f=e.encodeDST?{DST:e.encodeDST}:{},s=Object.assign({},e,f,i),d=Nt(o,1,s),u=r(d[0]);return c(u)},mapToCurve(o){if(!Array.isArray(o))throw new Error("expected array of bigints");for(const i of o)if(typeof i!="bigint")throw new Error("expected array of bigints");return c(r(o))},hashToScalar(o,i){const f=t.Fn.ORDER,s=Object.assign({},e,{p:f,m:1,DST:An},i);return Nt(o,1,s)[0][0]}}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const it=BigInt(0),rt=BigInt(1),ht=BigInt(2);function me(t){return ut(t,{adjustScalarBytes:"function",powPminus2:"function"}),Object.freeze({...t})}function ge(t){const n=me(t),{P:e,type:r,adjustScalarBytes:c,powPminus2:o,randomBytes:i}=n,f=r==="x25519";if(!f&&r!=="x448")throw new Error("invalid type");const s=i||dn,d=f?255:448,u=f?32:56,p=BigInt(f?9:5),a=BigInt(f?121665:39081),m=f?ht**BigInt(254):ht**BigInt(447),w=f?BigInt(8)*ht**BigInt(251)-rt:BigInt(4)*ht**BigInt(445)-rt,E=m+w+rt,g=x=>R(x,e),l=B(p);function B(x){return mn(g(x),u)}function b(x){const v=j("u coordinate",x,u);return f&&(v[31]&=127),g(F(v))}function I(x){return F(c(j("scalar",x,u)))}function N(x,v){const q=Z(b(v),I(x));if(q===it)throw new Error("invalid private or public key received");return B(q)}function A(x){return N(x,l)}function O(x,v,q){const M=g(x*(v-q));return v=g(v-M),q=g(q+M),{x_2:v,x_3:q}}function Z(x,v){mt("u",x,it,e),mt("scalar",v,m,E);const q=v,M=x;let L=rt,X=it,U=x,z=rt,D=it;for(let et=BigInt(d-1);et>=it;et--){const Bt=q>>et&rt;D^=Bt,{x_2:L,x_3:U}=O(D,L,U),{x_2:X,x_3:z}=O(D,X,z),D=Bt;const _t=L+X,bt=g(_t*_t),xt=L-X,kt=g(xt*xt),Kt=bt-kt,Un=U+z,Yn=U-z,Gt=g(Yn*_t),Pt=g(Un*xt),Ht=Gt+Pt,Qt=Gt-Pt;U=g(Ht*Ht),z=g(M*g(Qt*Qt)),L=g(bt*kt),X=g(Kt*(bt+g(a*Kt)))}({x_2:L,x_3:U}=O(D,L,U)),{x_2:X,x_3:z}=O(D,X,z);const st=o(X);return g(L*st)}const y={secretKey:u,publicKey:u,seed:u},_=(x=s(u))=>(nt(x,y.seed),x);function S(x){const v=_(x);return{secretKey:v,publicKey:A(v)}}return{keygen:S,getSharedSecret:(x,v)=>N(x,v),getPublicKey:x=>A(x),scalarMult:N,scalarMultBase:A,utils:{randomSecretKey:_,randomPrivateKey:_},GuBytes:l.slice(),lengths:y}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const ye=BigInt(0),K=BigInt(1),yt=BigInt(2),qn=BigInt(3),Nn=BigInt(5),$t=BigInt(8),H=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed"),dt={p:H,n:BigInt("0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed"),h:$t,a:BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec"),d:BigInt("0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3"),Gx:BigInt("0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a"),Gy:BigInt("0x6666666666666666666666666666666666666666666666666666666666666658")};function On(t){const n=BigInt(10),e=BigInt(20),r=BigInt(40),c=BigInt(80),o=H,f=t*t%o*t%o,s=k(f,yt,o)*f%o,d=k(s,K,o)*t%o,u=k(d,Nn,o)*d%o,p=k(u,n,o)*u%o,a=k(p,e,o)*p%o,m=k(a,r,o)*a%o,w=k(m,c,o)*m%o,E=k(w,c,o)*m%o,g=k(E,n,o)*u%o;return{pow_p_5_8:k(g,yt,o)*t%o,b2:f}}function Tn(t){return t[0]&=248,t[31]&=127,t[31]|=64,t}const Mt=BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");function zt(t,n){const e=H,r=R(n*n*n,e),c=R(r*r*n,e),o=On(t*c).pow_p_5_8;let i=R(t*r*o,e);const f=R(n*i*i,e),s=i,d=R(i*Mt,e),u=f===t,p=f===R(-t,e),a=f===R(-t*Mt,e);return u&&(i=s),(p||a)&&(i=d),W(i,e)&&(i=R(-i,e)),{isValid:u||p,value:i}}const h=ot(dt.p,{isLE:!0}),Zn=ot(dt.n,{isLE:!0}),Dt={...dt,Fp:h,hash:ct,adjustScalarBytes:Tn,uvRatio:zt},G=jt(Dt);function Rn(t,n,e){if(n.length>255)throw new Error("Context is too big");return P(at("SigEd25519 no Ed25519 collisions"),new Uint8Array([e?1:0,n.length]),n,t)}const Oe=jt({...Dt,domain:Rn}),Te=jt(Object.assign({},Dt,{domain:Rn,prehash:ct})),Ze=(()=>{const t=h.ORDER;return ge({P:t,type:"x25519",powPminus2:n=>{const{pow_p_5_8:e,b2:r}=On(n);return R(k(e,qn,t)*r,t)},adjustScalarBytes:Tn})})(),pe=(H+qn)/$t,Ee=h.pow(yt,pe),cn=h.sqrt(h.neg(h.ONE));function Be(t){const n=(H-Nn)/$t,e=BigInt(486662);let r=h.sqr(t);r=h.mul(r,yt);let c=h.add(r,h.ONE),o=h.neg(e),i=h.sqr(c),f=h.mul(i,c),s=h.mul(r,e);s=h.mul(s,o),s=h.add(s,i),s=h.mul(s,o);let d=h.sqr(f);i=h.sqr(d),d=h.mul(d,f),d=h.mul(d,s),i=h.mul(i,d);let u=h.pow(i,n);u=h.mul(u,d);let p=h.mul(u,cn);i=h.sqr(u),i=h.mul(i,f);let a=h.eql(i,s),m=h.cmov(p,u,a),w=h.mul(o,r),E=h.mul(u,t);E=h.mul(E,Ee);let g=h.mul(E,cn),l=h.mul(s,r);i=h.sqr(E),i=h.mul(i,f);let B=h.eql(i,l),b=h.cmov(g,E,B);i=h.sqr(m),i=h.mul(i,f);let I=h.eql(i,s),N=h.cmov(w,o,I),A=h.cmov(b,m,I),O=h.isOdd(A);return A=h.cmov(A,h.neg(A),I!==O),{xMn:N,xMd:c,yMn:A,yMd:K}}const _e=Fn(h,h.neg(BigInt(486664)));function be(t){const{xMn:n,xMd:e,yMn:r,yMd:c}=Be(t);let o=h.mul(n,c);o=h.mul(o,_e);let i=h.mul(e,r),f=h.sub(n,e),s=h.add(n,e),d=h.mul(i,s),u=h.eql(d,h.ZERO);o=h.cmov(o,h.ZERO,u),i=h.cmov(i,h.ONE,u),f=h.cmov(f,h.ONE,u),s=h.cmov(s,h.ONE,u);const[p,a]=Vt(h,[i,s],!0);return{x:h.mul(o,p),y:h.mul(f,a)}}const Mn=we(G.Point,t=>be(t[0]),{DST:"edwards25519_XMD:SHA-512_ELL2_RO_",encodeDST:"edwards25519_XMD:SHA-512_ELL2_NU_",p:H,m:1,k:128,expand:"xmd",hash:ct}),Ct=Mt,xe=BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235"),ve=BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578"),Se=BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838"),Ie=BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952"),fn=t=>zt(K,t),Ae=BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"),Lt=t=>G.Point.Fp.create(F(t)&Ae);function an(t){const{d:n}=dt,e=H,r=l=>h.create(l),c=r(Ct*t*t),o=r((c+K)*Se);let i=BigInt(-1);const f=r((i-n*c)*r(c+n));let{isValid:s,value:d}=zt(o,f),u=r(d*t);W(u,e)||(u=r(-u)),s||(d=u),s||(i=c);const p=r(i*(c-K)*Ie-f),a=d*d,m=r((d+d)*f),w=r(p*xe),E=r(K-a),g=r(K+a);return new G.Point(r(m*g),r(E*w),r(w*g),r(m*E))}function Cn(t){nt(t,64);const n=Lt(t.subarray(0,32)),e=an(n),r=Lt(t.subarray(32,64)),c=an(r);return new Y(e.add(c))}class Y extends ce{constructor(n){super(n)}static fromAffine(n){return new Y(G.Point.fromAffine(n))}assertSame(n){if(!(n instanceof Y))throw new Error("RistrettoPoint expected")}init(n){return new Y(n)}static hashToCurve(n){return Cn(j("ristrettoHash",n,64))}static fromBytes(n){nt(n,32);const{a:e,d:r}=dt,c=H,o=I=>h.create(I),i=Lt(n);if(!Vn(h.toBytes(i),n)||W(i,c))throw new Error("invalid ristretto255 encoding 1");const f=o(i*i),s=o(K+e*f),d=o(K-e*f),u=o(s*s),p=o(d*d),a=o(e*r*u-p),{isValid:m,value:w}=fn(o(a*p)),E=o(w*d),g=o(w*E*a);let l=o((i+i)*E);W(l,c)&&(l=o(-l));const B=o(s*g),b=o(l*B);if(!m||W(b,c)||B===ye)throw new Error("invalid ristretto255 encoding 2");return new Y(new G.Point(l,B,K,b))}static fromHex(n){return Y.fromBytes(j("ristrettoHex",n,32))}static msm(n,e){return Sn(Y,G.Point.Fn,n,e)}toBytes(){let{X:n,Y:e,Z:r,T:c}=this.ep;const o=H,i=g=>h.create(g),f=i(i(r+e)*i(r-e)),s=i(n*e),d=i(s*s),{value:u}=fn(i(f*d)),p=i(u*f),a=i(u*s),m=i(p*a*c);let w;if(W(c*m,o)){let g=i(e*Ct),l=i(n*Ct);n=g,e=l,w=i(p*ve)}else w=a;W(n*m,o)&&(e=i(-e));let E=i((r-e)*w);return W(E,o)&&(E=i(-E)),h.toBytes(E)}equals(n){this.assertSame(n);const{X:e,Y:r}=this.ep,{X:c,Y:o}=n.ep,i=d=>h.create(d),f=i(e*o)===i(r*c),s=i(r*o)===i(e*c);return f||s}is0(){return this.equals(Y.ZERO)}}Y.BASE=new Y(G.Point.BASE);Y.ZERO=new Y(G.Point.ZERO);Y.Fp=h;Y.Fn=Zn;const Re={Point:Y},Ln={hashToCurve(t,n){const e=(n==null?void 0:n.DST)||"ristretto255_XMD:SHA-512_R255MAP_RO_",r=Rt(t,e,64,ct);return Cn(r)},hashToScalar(t,n={DST:An}){const e=Rt(t,n.DST,64,ct);return Zn.create(F(e))}},Me=["0100000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a","0000000000000000000000000000000000000000000000000000000000000080","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05","ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f","26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85","0000000000000000000000000000000000000000000000000000000000000000","c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"];function qe(t){return G.utils.toMontgomery(j("pub",t))}const Ce=qe;function Le(t){return G.utils.toMontgomerySecret(j("pub",t))}const Ue=Y,Ye=Mn.hashToCurve,Xe=Mn.encodeToCurve,Ve=Ln.hashToCurve,je=Ln.hashToCurve;export{Me as ED25519_TORSION_SUBGROUP,Ue as RistrettoPoint,G as ed25519,Mn as ed25519_hasher,Oe as ed25519ctx,Te as ed25519ph,Ce as edwardsToMontgomery,Le as edwardsToMontgomeryPriv,qe as edwardsToMontgomeryPub,Xe as encodeToCurve,Ye as hashToCurve,Ve as hashToRistretto255,je as hash_to_ristretto255,Re as ristretto255,Ln as ristretto255_hasher,Ze as x25519};
